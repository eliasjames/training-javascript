Advanced Javascript 
- Review primitive types
  - JS has five primitive types
  - practically everything else is an object
    - functions, arrays, dates, etc
    - in ES6, only new data type 'symbol' is not 
  - typeof operator returns variable type (primitive or other)
  - Primitives are immutable
  - Primitives have no methods
  - JS will try to auto-convert primitives to their object versions to use methods
- Review Objects and Functions
  - Objects are collections of properties
  - Objects get created using literal or Object.create
  - Functions take arguments, execute statements, and return a value
  - Functions are also objects
- Prototype chain
  - objects inherit via a prototype from their creator
  - all objects therefore are descendents of Object
  - on the new object, reference to the prototype is a property named __proto__
  - when accessing an object property...
    - JS looks on the object first
    - then up the prototype chain
    - returns the first match
    - if no match at the global level, returns undefined
- Function context and the 'this' keyword
  - 'this' represents the object the function is acting on
  - can be passed in via call() or apply()
  - if not passed, and called from an object property, uses object as 'this'
  - if not passed, and not called from object, uses global object as 'this'
  - bind() permanently sets context (ES5)
- Inheritance & New
  - What 'new' does, in plain JS
    1. given some initialization function to do arbitrary setup tasks...
    2. use Object.create to make a new object by cloning another (sets __proto__ property on clonee to cloner)
    3. .call() the init function, passing new object from step 2 as context
    4. return the new object
  - Use 'new' as shortcut
    - set prototype property on init function to the cloner object
    - set prototype.constructor property on init functionto the init function
    - 'new' replaces steps 2, 3 and 4 above
  - Inheritance
    - create a child init function
      - within it, call the parent init function
      - pass 'this' as context
      - maybe pass arguments too
    - set prototype property to clone of the parent object
    - set value of prototype.constructor property to the child init function
- Function declarations versus expressions
  - Declarations
    - must be declared by name 
    - and then invoked by that name
  - Expressions
    - may be named or not
    - no longer a 'source element' - non-nested statement
    - can no longer be invoked by name
- Hoisting
